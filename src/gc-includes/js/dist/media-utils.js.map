{"version":3,"file":"media-utils.js","sources":["webpack://gc/webpack/bootstrap","webpack://gc/./node_modules/@gechiui/media-utils/build-module/components/@gechiui/media-utils/src/components/index.js","webpack://gc/./node_modules/@gechiui/media-utils/build-module/components/media-upload/@gechiui/media-utils/src/components/media-upload/index.js","webpack://gc/./node_modules/@gechiui/media-utils/build-module/@gechiui/media-utils/src/index.js","webpack://gc/./node_modules/@gechiui/media-utils/build-module/utils/@gechiui/media-utils/src/utils/index.js","webpack://gc/./node_modules/@gechiui/media-utils/build-module/utils/@gechiui/media-utils/src/utils/upload-media.js","webpack://gc/external [\"gc\",\"apiFetch\"]","webpack://gc/external [\"gc\",\"blob\"]","webpack://gc/external [\"gc\",\"element\"]","webpack://gc/external [\"gc\",\"i18n\"]","webpack://gc/external \"lodash\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/@gechiui/media-utils/build-module/index.js\");\n","export { default as MediaUpload } from './media-upload';\n","/**\n * External dependencies\n */\nimport { castArray, defaults, pick } from 'lodash';\n\n/**\n * GeChiUI dependencies\n */\nimport { Component } from '@gechiui/element';\nimport { __ } from '@gechiui/i18n';\n\nconst { gc } = window;\n\nconst DEFAULT_EMPTY_GALLERY = [];\n\n/**\n * Prepares the Featured Image toolbars and frames.\n *\n * @return {gc.media.view.MediaFrame.Select} The default media workflow.\n */\nconst getFeaturedImageMediaFrame = () => {\n\treturn gc.media.view.MediaFrame.Select.extend( {\n\t\t/**\n\t\t * Enables the Set Featured Image Button.\n\t\t *\n\t\t * @param {Object} toolbar toolbar for featured image state\n\t\t * @return {void}\n\t\t */\n\t\tfeaturedImageToolbar( toolbar ) {\n\t\t\tthis.createSelectToolbar( toolbar, {\n\t\t\t\ttext: gc.media.view.l10n.setFeaturedImage,\n\t\t\t\tstate: this.options.state,\n\t\t\t} );\n\t\t},\n\n\t\t/**\n\t\t * Handle the edit state requirements of selected media item.\n\t\t *\n\t\t * @return {void}\n\t\t */\n\t\teditState() {\n\t\t\tconst selection = this.state( 'featured-image' ).get( 'selection' );\n\t\t\tconst view = new gc.media.view.EditImage( {\n\t\t\t\tmodel: selection.single(),\n\t\t\t\tcontroller: this,\n\t\t\t} ).render();\n\n\t\t\t// Set the view to the EditImage frame using the selected image.\n\t\t\tthis.content.set( view );\n\n\t\t\t// After bringing in the frame, load the actual editor via an ajax call.\n\t\t\tview.loadEditor();\n\t\t},\n\n\t\t/**\n\t\t * Create the default states.\n\t\t *\n\t\t * @return {void}\n\t\t */\n\t\tcreateStates: function createStates() {\n\t\t\tthis.on(\n\t\t\t\t'toolbar:create:featured-image',\n\t\t\t\tthis.featuredImageToolbar,\n\t\t\t\tthis\n\t\t\t);\n\t\t\tthis.on( 'content:render:edit-image', this.editState, this );\n\n\t\t\tthis.states.add( [\n\t\t\t\tnew gc.media.controller.FeaturedImage(),\n\t\t\t\tnew gc.media.controller.EditImage( {\n\t\t\t\t\tmodel: this.options.editImage,\n\t\t\t\t} ),\n\t\t\t] );\n\t\t},\n\t} );\n};\n\n/**\n * Prepares the Gallery toolbars and frames.\n *\n * @return {gc.media.view.MediaFrame.Post} The default media workflow.\n */\nconst getGalleryDetailsMediaFrame = () => {\n\t/**\n\t * Custom gallery details frame.\n\t *\n\t * @see https://github.com/xgc/gc-core-media-widgets/blob/905edbccfc2a623b73a93dac803c5335519d7837/gc-admin/js/widgets/media-gallery-widget.js\n\t * @class GalleryDetailsMediaFrame\n\t * @class\n\t */\n\treturn gc.media.view.MediaFrame.Post.extend( {\n\t\t/**\n\t\t * Set up gallery toolbar.\n\t\t *\n\t\t * @return {void}\n\t\t */\n\t\tgalleryToolbar() {\n\t\t\tconst editing = this.state().get( 'editing' );\n\t\t\tthis.toolbar.set(\n\t\t\t\tnew gc.media.view.Toolbar( {\n\t\t\t\t\tcontroller: this,\n\t\t\t\t\titems: {\n\t\t\t\t\t\tinsert: {\n\t\t\t\t\t\t\tstyle: 'primary',\n\t\t\t\t\t\t\ttext: editing\n\t\t\t\t\t\t\t\t? gc.media.view.l10n.updateGallery\n\t\t\t\t\t\t\t\t: gc.media.view.l10n.insertGallery,\n\t\t\t\t\t\t\tpriority: 80,\n\t\t\t\t\t\t\trequires: { library: true },\n\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @fires gc.media.controller.State#update\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tclick() {\n\t\t\t\t\t\t\t\tconst controller = this.controller,\n\t\t\t\t\t\t\t\t\tstate = controller.state();\n\n\t\t\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\t\t\tstate.trigger(\n\t\t\t\t\t\t\t\t\t'update',\n\t\t\t\t\t\t\t\t\tstate.get( 'library' )\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t// Restore and reset the default state.\n\t\t\t\t\t\t\t\tcontroller.setState( controller.options.state );\n\t\t\t\t\t\t\t\tcontroller.reset();\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t} )\n\t\t\t);\n\t\t},\n\n\t\t/**\n\t\t * Handle the edit state requirements of selected media item.\n\t\t *\n\t\t * @return {void}\n\t\t */\n\t\teditState() {\n\t\t\tconst selection = this.state( 'gallery' ).get( 'selection' );\n\t\t\tconst view = new gc.media.view.EditImage( {\n\t\t\t\tmodel: selection.single(),\n\t\t\t\tcontroller: this,\n\t\t\t} ).render();\n\n\t\t\t// Set the view to the EditImage frame using the selected image.\n\t\t\tthis.content.set( view );\n\n\t\t\t// After bringing in the frame, load the actual editor via an ajax call.\n\t\t\tview.loadEditor();\n\t\t},\n\n\t\t/**\n\t\t * Create the default states.\n\t\t *\n\t\t * @return {void}\n\t\t */\n\t\tcreateStates: function createStates() {\n\t\t\tthis.on( 'toolbar:create:main-gallery', this.galleryToolbar, this );\n\t\t\tthis.on( 'content:render:edit-image', this.editState, this );\n\n\t\t\tthis.states.add( [\n\t\t\t\tnew gc.media.controller.Library( {\n\t\t\t\t\tid: 'gallery',\n\t\t\t\t\ttitle: gc.media.view.l10n.createGalleryTitle,\n\t\t\t\t\tpriority: 40,\n\t\t\t\t\ttoolbar: 'main-gallery',\n\t\t\t\t\tfilterable: 'uploaded',\n\t\t\t\t\tmultiple: 'add',\n\t\t\t\t\teditable: false,\n\n\t\t\t\t\tlibrary: gc.media.query(\n\t\t\t\t\t\tdefaults(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: 'image',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tthis.options.library\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t} ),\n\t\t\t\tnew gc.media.controller.EditImage( {\n\t\t\t\t\tmodel: this.options.editImage,\n\t\t\t\t} ),\n\n\t\t\t\tnew gc.media.controller.GalleryEdit( {\n\t\t\t\t\tlibrary: this.options.selection,\n\t\t\t\t\tediting: this.options.editing,\n\t\t\t\t\tmenu: 'gallery',\n\t\t\t\t\tdisplaySettings: false,\n\t\t\t\t\tmultiple: true,\n\t\t\t\t} ),\n\n\t\t\t\tnew gc.media.controller.GalleryAdd(),\n\t\t\t] );\n\t\t},\n\t} );\n};\n\n// the media library image object contains numerous attributes\n// we only need this set to display the image in the library\nconst slimImageObject = ( img ) => {\n\tconst attrSet = [\n\t\t'sizes',\n\t\t'mime',\n\t\t'type',\n\t\t'subtype',\n\t\t'id',\n\t\t'url',\n\t\t'alt',\n\t\t'link',\n\t\t'caption',\n\t];\n\treturn pick( img, attrSet );\n};\n\nconst getAttachmentsCollection = ( ids ) => {\n\treturn gc.media.query( {\n\t\torder: 'ASC',\n\t\torderby: 'post__in',\n\t\tpost__in: ids,\n\t\tposts_per_page: -1,\n\t\tquery: true,\n\t\ttype: 'image',\n\t} );\n};\n\nclass MediaUpload extends Component {\n\tconstructor( {\n\t\tallowedTypes,\n\t\tgallery = false,\n\t\tunstableFeaturedImageFlow = false,\n\t\tmodalClass,\n\t\tmultiple = false,\n\t\ttitle = __( 'Select or Upload Media' ),\n\t} ) {\n\t\tsuper( ...arguments );\n\t\tthis.openModal = this.openModal.bind( this );\n\t\tthis.onOpen = this.onOpen.bind( this );\n\t\tthis.onSelect = this.onSelect.bind( this );\n\t\tthis.onUpdate = this.onUpdate.bind( this );\n\t\tthis.onClose = this.onClose.bind( this );\n\n\t\tif ( gallery ) {\n\t\t\tthis.buildAndSetGalleryFrame();\n\t\t} else {\n\t\t\tconst frameConfig = {\n\t\t\t\ttitle,\n\t\t\t\tmultiple,\n\t\t\t};\n\t\t\tif ( !! allowedTypes ) {\n\t\t\t\tframeConfig.library = { type: allowedTypes };\n\t\t\t}\n\n\t\t\tthis.frame = gc.media( frameConfig );\n\t\t}\n\n\t\tif ( modalClass ) {\n\t\t\tthis.frame.$el.addClass( modalClass );\n\t\t}\n\n\t\tif ( unstableFeaturedImageFlow ) {\n\t\t\tthis.buildAndSetFeatureImageFrame();\n\t\t}\n\t\tthis.initializeListeners();\n\t}\n\n\tinitializeListeners() {\n\t\t// When an image is selected in the media frame...\n\t\tthis.frame.on( 'select', this.onSelect );\n\t\tthis.frame.on( 'update', this.onUpdate );\n\t\tthis.frame.on( 'open', this.onOpen );\n\t\tthis.frame.on( 'close', this.onClose );\n\t}\n\n\t/**\n\t * Sets the Gallery frame and initializes listeners.\n\t *\n\t * @return {void}\n\t */\n\tbuildAndSetGalleryFrame() {\n\t\tconst {\n\t\t\taddToGallery = false,\n\t\t\tallowedTypes,\n\t\t\tmultiple = false,\n\t\t\tvalue = DEFAULT_EMPTY_GALLERY,\n\t\t} = this.props;\n\n\t\t// If the value did not changed there is no need to rebuild the frame,\n\t\t// we can continue to use the existing one.\n\t\tif ( value === this.lastGalleryValue ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.lastGalleryValue = value;\n\n\t\t// If a frame already existed remove it.\n\t\tif ( this.frame ) {\n\t\t\tthis.frame.remove();\n\t\t}\n\t\tlet currentState;\n\t\tif ( addToGallery ) {\n\t\t\tcurrentState = 'gallery-library';\n\t\t} else {\n\t\t\tcurrentState = value && value.length ? 'gallery-edit' : 'gallery';\n\t\t}\n\t\tif ( ! this.GalleryDetailsMediaFrame ) {\n\t\t\tthis.GalleryDetailsMediaFrame = getGalleryDetailsMediaFrame();\n\t\t}\n\t\tconst attachments = getAttachmentsCollection( value );\n\t\tconst selection = new gc.media.model.Selection( attachments.models, {\n\t\t\tprops: attachments.props.toJSON(),\n\t\t\tmultiple,\n\t\t} );\n\t\tthis.frame = new this.GalleryDetailsMediaFrame( {\n\t\t\tmimeType: allowedTypes,\n\t\t\tstate: currentState,\n\t\t\tmultiple,\n\t\t\tselection,\n\t\t\tediting: value && value.length ? true : false,\n\t\t} );\n\t\tgc.media.frame = this.frame;\n\t\tthis.initializeListeners();\n\t}\n\n\t/**\n\t * Initializes the Media Library requirements for the featured image flow.\n\t *\n\t * @return {void}\n\t */\n\tbuildAndSetFeatureImageFrame() {\n\t\tconst featuredImageFrame = getFeaturedImageMediaFrame();\n\t\tconst attachments = getAttachmentsCollection( this.props.value );\n\t\tconst selection = new gc.media.model.Selection( attachments.models, {\n\t\t\tprops: attachments.props.toJSON(),\n\t\t} );\n\t\tthis.frame = new featuredImageFrame( {\n\t\t\tmimeType: this.props.allowedTypes,\n\t\t\tstate: 'featured-image',\n\t\t\tmultiple: this.props.multiple,\n\t\t\tselection,\n\t\t\tediting: this.props.value ? true : false,\n\t\t} );\n\t\tgc.media.frame = this.frame;\n\t}\n\n\tcomponentWillUnmount() {\n\t\tthis.frame.remove();\n\t}\n\n\tonUpdate( selections ) {\n\t\tconst { onSelect, multiple = false } = this.props;\n\t\tconst state = this.frame.state();\n\t\tconst selectedImages = selections || state.get( 'selection' );\n\n\t\tif ( ! selectedImages || ! selectedImages.models.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( multiple ) {\n\t\t\tonSelect(\n\t\t\t\tselectedImages.models.map( ( model ) =>\n\t\t\t\t\tslimImageObject( model.toJSON() )\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tonSelect( slimImageObject( selectedImages.models[ 0 ].toJSON() ) );\n\t\t}\n\t}\n\n\tonSelect() {\n\t\tconst { onSelect, multiple = false } = this.props;\n\t\t// Get media attachment details from the frame state\n\t\tconst attachment = this.frame.state().get( 'selection' ).toJSON();\n\t\tonSelect( multiple ? attachment : attachment[ 0 ] );\n\t}\n\n\tonOpen() {\n\t\tthis.updateCollection();\n\n\t\t// Handle both this.props.value being either (number[]) multiple ids\n\t\t// (for galleries) or a (number) singular id (e.g. image block).\n\t\tconst hasMedia = Array.isArray( this.props.value )\n\t\t\t? !! this.props.value?.length\n\t\t\t: !! this.props.value;\n\n\t\tif ( ! hasMedia ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isGallery = this.props.gallery;\n\t\tconst selection = this.frame.state().get( 'selection' );\n\n\t\tif ( ! isGallery ) {\n\t\t\tcastArray( this.props.value ).forEach( ( id ) => {\n\t\t\t\tselection.add( gc.media.attachment( id ) );\n\t\t\t} );\n\t\t}\n\n\t\t// Load the images so they are available in the media modal.\n\t\tconst attachments = getAttachmentsCollection(\n\t\t\tcastArray( this.props.value )\n\t\t);\n\n\t\t// Once attachments are loaded, set the current selection.\n\t\tattachments.more().done( function () {\n\t\t\tif ( isGallery && attachments?.models?.length ) {\n\t\t\t\tselection.add( attachments.models );\n\t\t\t}\n\t\t} );\n\t}\n\n\tonClose() {\n\t\tconst { onClose } = this.props;\n\n\t\tif ( onClose ) {\n\t\t\tonClose();\n\t\t}\n\t}\n\n\tupdateCollection() {\n\t\tconst frameContent = this.frame.content.get();\n\t\tif ( frameContent && frameContent.collection ) {\n\t\t\tconst collection = frameContent.collection;\n\n\t\t\t// clean all attachments we have in memory.\n\t\t\tcollection\n\t\t\t\t.toArray()\n\t\t\t\t.forEach( ( model ) => model.trigger( 'destroy', model ) );\n\n\t\t\t// reset has more flag, if library had small amount of items all items may have been loaded before.\n\t\t\tcollection.mirroring._hasMore = true;\n\n\t\t\t// request items\n\t\t\tcollection.more();\n\t\t}\n\t}\n\n\topenModal() {\n\t\tif ( this.props.gallery ) {\n\t\t\tthis.buildAndSetGalleryFrame();\n\t\t}\n\t\tthis.frame.open();\n\t}\n\n\trender() {\n\t\treturn this.props.render( { open: this.openModal } );\n\t}\n}\n\nexport default MediaUpload;\n","export * from './components';\nexport * from './utils';\n","export { uploadMedia } from './upload-media';\n","/**\n * External dependencies\n */\nimport {\n\tcompact,\n\tflatMap,\n\tforEach,\n\tget,\n\thas,\n\tincludes,\n\tmap,\n\tnoop,\n\tomit,\n\tsome,\n\tstartsWith,\n} from 'lodash';\n\n/**\n * GeChiUI dependencies\n */\nimport apiFetch from '@gechiui/api-fetch';\nimport { createBlobURL, revokeBlobURL } from '@gechiui/blob';\nimport { __, sprintf } from '@gechiui/i18n';\n\n/**\n * Browsers may use unexpected mime types, and they differ from browser to browser.\n * This function computes a flexible array of mime types from the mime type structured provided by the server.\n * Converts { jpg|jpeg|jpe: \"image/jpeg\" } into [ \"image/jpeg\", \"image/jpg\", \"image/jpeg\", \"image/jpe\" ]\n * The computation of this array instead of directly using the object,\n * solves the problem in chrome where mp3 files have audio/mp3 as mime type instead of audio/mpeg.\n * https://bugs.chromium.org/p/chromium/issues/detail?id=227004\n *\n * @param {?Object} gcMimeTypesObject Mime type object received from the server.\n *                                    Extensions are keys separated by '|' and values are mime types associated with an extension.\n *\n * @return {?Array} An array of mime types or the parameter passed if it was \"falsy\".\n */\nexport function getMimeTypesArray( gcMimeTypesObject ) {\n\tif ( ! gcMimeTypesObject ) {\n\t\treturn gcMimeTypesObject;\n\t}\n\treturn flatMap( gcMimeTypesObject, ( mime, extensionsString ) => {\n\t\tconst [ type ] = mime.split( '/' );\n\t\tconst extensions = extensionsString.split( '|' );\n\t\treturn [\n\t\t\tmime,\n\t\t\t...map( extensions, ( extension ) => `${ type }/${ extension }` ),\n\t\t];\n\t} );\n}\n\n/**\n *\tMedia Upload is used by audio, image, gallery, video, and file blocks to\n *\thandle uploading a media file when a file upload button is activated.\n *\n *\tTODO: future enhancement to add an upload indicator.\n *\n * @param {Object}   $0                    Parameters object passed to the function.\n * @param {?Array}   $0.allowedTypes       Array with the types of media that can be uploaded, if unset all types are allowed.\n * @param {?Object}  $0.additionalData     Additional data to include in the request.\n * @param {Array}    $0.filesList          List of files.\n * @param {?number}  $0.maxUploadFileSize  Maximum upload size in bytes allowed for the site.\n * @param {Function} $0.onError            Function called when an error happens.\n * @param {Function} $0.onFileChange       Function called each time a file or a temporary representation of the file is available.\n * @param {?Object}  $0.gcAllowedMimeTypes List of allowed mime types and file extensions.\n */\nexport async function uploadMedia( {\n\tallowedTypes,\n\tadditionalData = {},\n\tfilesList,\n\tmaxUploadFileSize,\n\tonError = noop,\n\tonFileChange,\n\tgcAllowedMimeTypes = null,\n} ) {\n\t// Cast filesList to array\n\tconst files = [ ...filesList ];\n\n\tconst filesSet = [];\n\tconst setAndUpdateFiles = ( idx, value ) => {\n\t\trevokeBlobURL( get( filesSet, [ idx, 'url' ] ) );\n\t\tfilesSet[ idx ] = value;\n\t\tonFileChange( compact( filesSet ) );\n\t};\n\n\t// Allowed type specified by consumer\n\tconst isAllowedType = ( fileType ) => {\n\t\tif ( ! allowedTypes ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn some( allowedTypes, ( allowedType ) => {\n\t\t\t// If a complete mimetype is specified verify if it matches exactly the mime type of the file.\n\t\t\tif ( includes( allowedType, '/' ) ) {\n\t\t\t\treturn allowedType === fileType;\n\t\t\t}\n\t\t\t// Otherwise a general mime type is used and we should verify if the file mimetype starts with it.\n\t\t\treturn startsWith( fileType, `${ allowedType }/` );\n\t\t} );\n\t};\n\n\t// Allowed types for the current GC_User\n\tconst allowedMimeTypesForUser = getMimeTypesArray( gcAllowedMimeTypes );\n\tconst isAllowedMimeTypeForUser = ( fileType ) => {\n\t\treturn includes( allowedMimeTypesForUser, fileType );\n\t};\n\n\t// Build the error message including the filename\n\tconst triggerError = ( error ) => {\n\t\terror.message = [\n\t\t\t<strong key=\"filename\">{ error.file.name }</strong>,\n\t\t\t': ',\n\t\t\terror.message,\n\t\t];\n\n\t\tonError( error );\n\t};\n\n\tconst validFiles = [];\n\n\tfor ( const mediaFile of files ) {\n\t\t// Verify if user is allowed to upload this mime type.\n\t\t// Defer to the server when type not detected.\n\t\tif (\n\t\t\tallowedMimeTypesForUser &&\n\t\t\tmediaFile.type &&\n\t\t\t! isAllowedMimeTypeForUser( mediaFile.type )\n\t\t) {\n\t\t\ttriggerError( {\n\t\t\t\tcode: 'MIME_TYPE_NOT_ALLOWED_FOR_USER',\n\t\t\t\tmessage: __(\n\t\t\t\t\t'Sorry, you are not allowed to upload this file type.'\n\t\t\t\t),\n\t\t\t\tfile: mediaFile,\n\t\t\t} );\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check if the block supports this mime type.\n\t\t// Defer to the server when type not detected.\n\t\tif ( mediaFile.type && ! isAllowedType( mediaFile.type ) ) {\n\t\t\ttriggerError( {\n\t\t\t\tcode: 'MIME_TYPE_NOT_SUPPORTED',\n\t\t\t\tmessage: __( 'Sorry, this file type is not supported here.' ),\n\t\t\t\tfile: mediaFile,\n\t\t\t} );\n\t\t\tcontinue;\n\t\t}\n\n\t\t// verify if file is greater than the maximum file upload size allowed for the site.\n\t\tif ( maxUploadFileSize && mediaFile.size > maxUploadFileSize ) {\n\t\t\ttriggerError( {\n\t\t\t\tcode: 'SIZE_ABOVE_LIMIT',\n\t\t\t\tmessage: __(\n\t\t\t\t\t'This file exceeds the maximum upload size for this site.'\n\t\t\t\t),\n\t\t\t\tfile: mediaFile,\n\t\t\t} );\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Don't allow empty files to be uploaded.\n\t\tif ( mediaFile.size <= 0 ) {\n\t\t\ttriggerError( {\n\t\t\t\tcode: 'EMPTY_FILE',\n\t\t\t\tmessage: __( 'This file is empty.' ),\n\t\t\t\tfile: mediaFile,\n\t\t\t} );\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalidFiles.push( mediaFile );\n\n\t\t// Set temporary URL to create placeholder media file, this is replaced\n\t\t// with final file from media gallery when upload is `done` below\n\t\tfilesSet.push( { url: createBlobURL( mediaFile ) } );\n\t\tonFileChange( filesSet );\n\t}\n\n\tfor ( let idx = 0; idx < validFiles.length; ++idx ) {\n\t\tconst mediaFile = validFiles[ idx ];\n\t\ttry {\n\t\t\tconst savedMedia = await createMediaFromFile(\n\t\t\t\tmediaFile,\n\t\t\t\tadditionalData\n\t\t\t);\n\t\t\tconst mediaObject = {\n\t\t\t\t...omit( savedMedia, [ 'alt_text', 'source_url' ] ),\n\t\t\t\talt: savedMedia.alt_text,\n\t\t\t\tcaption: get( savedMedia, [ 'caption', 'raw' ], '' ),\n\t\t\t\ttitle: savedMedia.title.raw,\n\t\t\t\turl: savedMedia.source_url,\n\t\t\t};\n\t\t\tsetAndUpdateFiles( idx, mediaObject );\n\t\t} catch ( error ) {\n\t\t\t// Reset to empty on failure.\n\t\t\tsetAndUpdateFiles( idx, null );\n\t\t\tlet message;\n\t\t\tif ( has( error, [ 'message' ] ) ) {\n\t\t\t\tmessage = get( error, [ 'message' ] );\n\t\t\t} else {\n\t\t\t\tmessage = sprintf(\n\t\t\t\t\t// translators: %s: file name\n\t\t\t\t\t__( 'Error while uploading file %s to the media library.' ),\n\t\t\t\t\tmediaFile.name\n\t\t\t\t);\n\t\t\t}\n\t\t\tonError( {\n\t\t\t\tcode: 'GENERAL',\n\t\t\t\tmessage,\n\t\t\t\tfile: mediaFile,\n\t\t\t} );\n\t\t}\n\t}\n}\n\n/**\n * @param {File}    file           Media File to Save.\n * @param {?Object} additionalData Additional data to include in the request.\n *\n * @return {Promise} Media Object Promise.\n */\nfunction createMediaFromFile( file, additionalData ) {\n\t// Create upload payload\n\tconst data = new window.FormData();\n\tdata.append( 'file', file, file.name || file.type.replace( '/', '.' ) );\n\tforEach( additionalData, ( value, key ) => data.append( key, value ) );\n\treturn apiFetch( {\n\t\tpath: '/gc/v2/media',\n\t\tbody: data,\n\t\tmethod: 'POST',\n\t} );\n}\n","(function() { module.exports = window[\"gc\"][\"apiFetch\"]; }());","(function() { module.exports = window[\"gc\"][\"blob\"]; }());","(function() { module.exports = window[\"gc\"][\"element\"]; }());","(function() { module.exports = window[\"gc\"][\"i18n\"]; }());","(function() { module.exports = window[\"lodash\"]; }());"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AAGA;AADA;AAIA;AApDA;AAsDA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAKA;AACA;AACA;AACA;AAzBA;AADA;AAFA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AADA;AAXA;AAmBA;AADA;AAKA;AACA;AACA;AACA;AACA;AALA;AAUA;AAxGA;AA0GA;AAGA;AACA;AACA;AADA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AAOA;AANA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAJA;AAQA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AA7NA;AACA;AA8NA;;;;;;;;;;;;;ACjcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAQA;AAPA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAGA;AALA;AAOA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AAEA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;;;;;;;;;;;ACvOA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}