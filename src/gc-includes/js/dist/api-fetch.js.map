{"version":3,"file":"api-fetch.js","sources":["webpack://gc/webpack/bootstrap","webpack://gc/./node_modules/@gechiui/api-fetch/build-module/@gechiui/api-fetch/src/index.js","webpack://gc/./node_modules/@gechiui/api-fetch/build-module/middlewares/@gechiui/api-fetch/src/middlewares/fetch-all-middleware.js","webpack://gc/./node_modules/@gechiui/api-fetch/build-module/middlewares/@gechiui/api-fetch/src/middlewares/http-v1.js","webpack://gc/./node_modules/@gechiui/api-fetch/build-module/middlewares/@gechiui/api-fetch/src/middlewares/media-upload.js","webpack://gc/./node_modules/@gechiui/api-fetch/build-module/middlewares/@gechiui/api-fetch/src/middlewares/namespace-endpoint.js","webpack://gc/./node_modules/@gechiui/api-fetch/build-module/middlewares/@gechiui/api-fetch/src/middlewares/nonce.js","webpack://gc/./node_modules/@gechiui/api-fetch/build-module/middlewares/@gechiui/api-fetch/src/middlewares/preloading.js","webpack://gc/./node_modules/@gechiui/api-fetch/build-module/middlewares/@gechiui/api-fetch/src/middlewares/root-url.js","webpack://gc/./node_modules/@gechiui/api-fetch/build-module/middlewares/@gechiui/api-fetch/src/middlewares/user-locale.js","webpack://gc/./node_modules/@gechiui/api-fetch/build-module/utils/@gechiui/api-fetch/src/utils/response.js","webpack://gc/external [\"gc\",\"i18n\"]","webpack://gc/external [\"gc\",\"url\"]"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/@gechiui/api-fetch/build-module/index.js\");\n","/**\n * GeChiUI dependencies\n */\nimport { __ } from '@gechiui/i18n';\n\n/**\n * Internal dependencies\n */\nimport createNonceMiddleware from './middlewares/nonce';\nimport createRootURLMiddleware from './middlewares/root-url';\nimport createPreloadingMiddleware from './middlewares/preloading';\nimport fetchAllMiddleware from './middlewares/fetch-all-middleware';\nimport namespaceEndpointMiddleware from './middlewares/namespace-endpoint';\nimport httpV1Middleware from './middlewares/http-v1';\nimport userLocaleMiddleware from './middlewares/user-locale';\nimport mediaUploadMiddleware from './middlewares/media-upload';\nimport {\n\tparseResponseAndNormalizeError,\n\tparseAndThrowError,\n} from './utils/response';\n\n/**\n * Default set of header values which should be sent with every request unless\n * explicitly provided through apiFetch options.\n *\n * @type {Record<string, string>}\n */\nconst DEFAULT_HEADERS = {\n\t// The backend uses the Accept header as a condition for considering an\n\t// incoming request as a REST request.\n\t//\n\t// See: https://core.trac.gechiui.com/ticket/44534\n\tAccept: 'application/json, */*;q=0.1',\n};\n\n/**\n * Default set of fetch option values which should be sent with every request\n * unless explicitly provided through apiFetch options.\n *\n * @type {Object}\n */\nconst DEFAULT_OPTIONS = {\n\tcredentials: 'include',\n};\n\n/** @typedef {import('./types').APIFetchMiddleware} APIFetchMiddleware */\n/** @typedef {import('./types').APIFetchOptions} APIFetchOptions */\n\n/**\n * @type {import('./types').APIFetchMiddleware[]}\n */\nconst middlewares = [\n\tuserLocaleMiddleware,\n\tnamespaceEndpointMiddleware,\n\thttpV1Middleware,\n\tfetchAllMiddleware,\n];\n\n/**\n * Register a middleware\n *\n * @param {import('./types').APIFetchMiddleware} middleware\n */\nfunction registerMiddleware( middleware ) {\n\tmiddlewares.unshift( middleware );\n}\n\n/**\n * Checks the status of a response, throwing the Response as an error if\n * it is outside the 200 range.\n *\n * @param {Response} response\n * @return {Response} The response if the status is in the 200 range.\n */\nconst checkStatus = ( response ) => {\n\tif ( response.status >= 200 && response.status < 300 ) {\n\t\treturn response;\n\t}\n\n\tthrow response;\n};\n\n/** @typedef {(options: import('./types').APIFetchOptions) => Promise<any>} FetchHandler*/\n\n/**\n * @type {FetchHandler}\n */\nconst defaultFetchHandler = ( nextOptions ) => {\n\tconst { url, path, data, parse = true, ...remainingOptions } = nextOptions;\n\tlet { body, headers } = nextOptions;\n\n\t// Merge explicitly-provided headers with default values.\n\theaders = { ...DEFAULT_HEADERS, ...headers };\n\n\t// The `data` property is a shorthand for sending a JSON body.\n\tif ( data ) {\n\t\tbody = JSON.stringify( data );\n\t\theaders[ 'Content-Type' ] = 'application/json';\n\t}\n\n\tconst responsePromise = window.fetch(\n\t\t// fall back to explicitly passing `window.location` which is the behavior if `undefined` is passed\n\t\turl || path || window.location.href,\n\t\t{\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...remainingOptions,\n\t\t\tbody,\n\t\t\theaders,\n\t\t}\n\t);\n\n\treturn responsePromise.then(\n\t\t( value ) =>\n\t\t\tPromise.resolve( value )\n\t\t\t\t.then( checkStatus )\n\t\t\t\t.catch( ( response ) => parseAndThrowError( response, parse ) )\n\t\t\t\t.then( ( response ) =>\n\t\t\t\t\tparseResponseAndNormalizeError( response, parse )\n\t\t\t\t),\n\t\t( err ) => {\n\t\t\t// Re-throw AbortError for the users to handle it themselves.\n\t\t\tif ( err && err.name === 'AbortError' ) {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\t// Otherwise, there is most likely no network connection.\n\t\t\t// Unfortunately the message might depend on the browser.\n\t\t\tthrow {\n\t\t\t\tcode: 'fetch_error',\n\t\t\t\tmessage: __( 'You are probably offline.' ),\n\t\t\t};\n\t\t}\n\t);\n};\n\n/** @type {FetchHandler} */\nlet fetchHandler = defaultFetchHandler;\n\n/**\n * Defines a custom fetch handler for making the requests that will override\n * the default one using window.fetch\n *\n * @param {FetchHandler} newFetchHandler The new fetch handler\n */\nfunction setFetchHandler( newFetchHandler ) {\n\tfetchHandler = newFetchHandler;\n}\n\n/**\n * @template T\n * @param {import('./types').APIFetchOptions} options\n * @return {Promise<T>} A promise representing the request processed via the registered middlewares.\n */\nfunction apiFetch( options ) {\n\t// creates a nested function chain that calls all middlewares and finally the `fetchHandler`,\n\t// converting `middlewares = [ m1, m2, m3 ]` into:\n\t// ```\n\t// opts1 => m1( opts1, opts2 => m2( opts2, opts3 => m3( opts3, fetchHandler ) ) );\n\t// ```\n\tconst enhancedHandler = middlewares.reduceRight( (\n\t\t/** @type {FetchHandler} */ next,\n\t\tmiddleware\n\t) => {\n\t\treturn ( workingOptions ) => middleware( workingOptions, next );\n\t}, fetchHandler );\n\n\treturn enhancedHandler( options ).catch( ( error ) => {\n\t\tif ( error.code !== 'rest_cookie_invalid_nonce' ) {\n\t\t\treturn Promise.reject( error );\n\t\t}\n\n\t\t// If the nonce is invalid, refresh it and try again.\n\t\treturn (\n\t\t\twindow\n\t\t\t\t// @ts-ignore\n\t\t\t\t.fetch( apiFetch.nonceEndpoint )\n\t\t\t\t.then( checkStatus )\n\t\t\t\t.then( ( data ) => data.text() )\n\t\t\t\t.then( ( text ) => {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tapiFetch.nonceMiddleware.nonce = text;\n\t\t\t\t\treturn apiFetch( options );\n\t\t\t\t} )\n\t\t);\n\t} );\n}\n\napiFetch.use = registerMiddleware;\napiFetch.setFetchHandler = setFetchHandler;\n\napiFetch.createNonceMiddleware = createNonceMiddleware;\napiFetch.createPreloadingMiddleware = createPreloadingMiddleware;\napiFetch.createRootURLMiddleware = createRootURLMiddleware;\napiFetch.fetchAllMiddleware = fetchAllMiddleware;\napiFetch.mediaUploadMiddleware = mediaUploadMiddleware;\n\nexport default apiFetch;\n","/**\n * GeChiUI dependencies\n */\nimport { addQueryArgs } from '@gechiui/url';\n\n/**\n * Internal dependencies\n */\nimport apiFetch from '..';\n\n/**\n * Apply query arguments to both URL and Path, whichever is present.\n *\n * @param {import('../types').APIFetchOptions} props\n * @param {Record<string, string | number>}    queryArgs\n * @return {import('../types').APIFetchOptions} The request with the modified query args\n */\nconst modifyQuery = ( { path, url, ...options }, queryArgs ) => ( {\n\t...options,\n\turl: url && addQueryArgs( url, queryArgs ),\n\tpath: path && addQueryArgs( path, queryArgs ),\n} );\n\n/**\n * Duplicates parsing functionality from apiFetch.\n *\n * @param {Response} response\n * @return {Promise<any>} Parsed response json.\n */\nconst parseResponse = ( response ) =>\n\tresponse.json ? response.json() : Promise.reject( response );\n\n/**\n * @param {string | null} linkHeader\n * @return {{ next?: string }} The parsed link header.\n */\nconst parseLinkHeader = ( linkHeader ) => {\n\tif ( ! linkHeader ) {\n\t\treturn {};\n\t}\n\tconst match = linkHeader.match( /<([^>]+)>; rel=\"next\"/ );\n\treturn match\n\t\t? {\n\t\t\t\tnext: match[ 1 ],\n\t\t  }\n\t\t: {};\n};\n\n/**\n * @param {Response} response\n * @return {string | undefined} The next page URL.\n */\nconst getNextPageUrl = ( response ) => {\n\tconst { next } = parseLinkHeader( response.headers.get( 'link' ) );\n\treturn next;\n};\n\n/**\n * @param {import('../types').APIFetchOptions} options\n * @return {boolean} True if the request contains an unbounded query.\n */\nconst requestContainsUnboundedQuery = ( options ) => {\n\tconst pathIsUnbounded =\n\t\t!! options.path && options.path.indexOf( 'per_page=-1' ) !== -1;\n\tconst urlIsUnbounded =\n\t\t!! options.url && options.url.indexOf( 'per_page=-1' ) !== -1;\n\treturn pathIsUnbounded || urlIsUnbounded;\n};\n\n/**\n * The REST API enforces an upper limit on the per_page option. To handle large\n * collections, apiFetch consumers can pass `per_page=-1`; this middleware will\n * then recursively assemble a full response array from all available pages.\n *\n * @type {import('../types').APIFetchMiddleware}\n */\nconst fetchAllMiddleware = async ( options, next ) => {\n\tif ( options.parse === false ) {\n\t\t// If a consumer has opted out of parsing, do not apply middleware.\n\t\treturn next( options );\n\t}\n\tif ( ! requestContainsUnboundedQuery( options ) ) {\n\t\t// If neither url nor path is requesting all items, do not apply middleware.\n\t\treturn next( options );\n\t}\n\n\t// Retrieve requested page of results.\n\tconst response = await apiFetch( {\n\t\t...modifyQuery( options, {\n\t\t\tper_page: 100,\n\t\t} ),\n\t\t// Ensure headers are returned for page 1.\n\t\tparse: false,\n\t} );\n\n\tconst results = await parseResponse( response );\n\n\tif ( ! Array.isArray( results ) ) {\n\t\t// We have no reliable way of merging non-array results.\n\t\treturn results;\n\t}\n\n\tlet nextPage = getNextPageUrl( response );\n\n\tif ( ! nextPage ) {\n\t\t// There are no further pages to request.\n\t\treturn results;\n\t}\n\n\t// Iteratively fetch all remaining pages until no \"next\" header is found.\n\tlet mergedResults = /** @type {any[]} */ ( [] ).concat( results );\n\twhile ( nextPage ) {\n\t\tconst nextResponse = await apiFetch( {\n\t\t\t...options,\n\t\t\t// Ensure the URL for the next page is used instead of any provided path.\n\t\t\tpath: undefined,\n\t\t\turl: nextPage,\n\t\t\t// Ensure we still get headers so we can identify the next page.\n\t\t\tparse: false,\n\t\t} );\n\t\tconst nextResults = await parseResponse( nextResponse );\n\t\tmergedResults = mergedResults.concat( nextResults );\n\t\tnextPage = getNextPageUrl( nextResponse );\n\t}\n\treturn mergedResults;\n};\n\nexport default fetchAllMiddleware;\n","/**\n * Set of HTTP methods which are eligible to be overridden.\n *\n * @type {Set<string>}\n */\nconst OVERRIDE_METHODS = new Set( [ 'PATCH', 'PUT', 'DELETE' ] );\n\n/**\n * Default request method.\n *\n * \"A request has an associated method (a method). Unless stated otherwise it\n * is `GET`.\"\n *\n * @see  https://fetch.spec.whatwg.org/#requests\n *\n * @type {string}\n */\nconst DEFAULT_METHOD = 'GET';\n\n/**\n * API Fetch middleware which overrides the request method for HTTP v1\n * compatibility leveraging the REST API X-HTTP-Method-Override header.\n *\n * @type {import('../types').APIFetchMiddleware}\n */\nconst httpV1Middleware = ( options, next ) => {\n\tconst { method = DEFAULT_METHOD } = options;\n\tif ( OVERRIDE_METHODS.has( method.toUpperCase() ) ) {\n\t\toptions = {\n\t\t\t...options,\n\t\t\theaders: {\n\t\t\t\t...options.headers,\n\t\t\t\t'X-HTTP-Method-Override': method,\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t},\n\t\t\tmethod: 'POST',\n\t\t};\n\t}\n\n\treturn next( options );\n};\n\nexport default httpV1Middleware;\n","/**\n * GeChiUI dependencies\n */\nimport { __ } from '@gechiui/i18n';\n\n/**\n * Internal dependencies\n */\nimport {\n\tparseAndThrowError,\n\tparseResponseAndNormalizeError,\n} from '../utils/response';\n\n/**\n * @param {import('../types').APIFetchOptions} options\n * @return {boolean} True if the request is for media upload.\n */\nfunction isMediaUploadRequest( options ) {\n\tconst isCreateMethod = !! options.method && options.method === 'POST';\n\tconst isMediaEndpoint =\n\t\t( !! options.path && options.path.indexOf( '/gc/v2/media' ) !== -1 ) ||\n\t\t( !! options.url && options.url.indexOf( '/gc/v2/media' ) !== -1 );\n\n\treturn isMediaEndpoint && isCreateMethod;\n}\n\n/**\n * Middleware handling media upload failures and retries.\n *\n * @type {import('../types').APIFetchMiddleware}\n */\nconst mediaUploadMiddleware = ( options, next ) => {\n\tif ( ! isMediaUploadRequest( options ) ) {\n\t\treturn next( options );\n\t}\n\n\tlet retries = 0;\n\tconst maxRetries = 5;\n\n\t/**\n\t * @param {string} attachmentId\n\t * @return {Promise<any>} Processed post response.\n\t */\n\tconst postProcess = ( attachmentId ) => {\n\t\tretries++;\n\t\treturn next( {\n\t\t\tpath: `/gc/v2/media/${ attachmentId }/post-process`,\n\t\t\tmethod: 'POST',\n\t\t\tdata: { action: 'create-image-subsizes' },\n\t\t\tparse: false,\n\t\t} ).catch( () => {\n\t\t\tif ( retries < maxRetries ) {\n\t\t\t\treturn postProcess( attachmentId );\n\t\t\t}\n\t\t\tnext( {\n\t\t\t\tpath: `/gc/v2/media/${ attachmentId }?force=true`,\n\t\t\t\tmethod: 'DELETE',\n\t\t\t} );\n\n\t\t\treturn Promise.reject();\n\t\t} );\n\t};\n\n\treturn next( { ...options, parse: false } )\n\t\t.catch( ( response ) => {\n\t\t\tconst attachmentId = response.headers.get(\n\t\t\t\t'x-gc-upload-attachment-id'\n\t\t\t);\n\t\t\tif (\n\t\t\t\tresponse.status >= 500 &&\n\t\t\t\tresponse.status < 600 &&\n\t\t\t\tattachmentId\n\t\t\t) {\n\t\t\t\treturn postProcess( attachmentId ).catch( () => {\n\t\t\t\t\tif ( options.parse !== false ) {\n\t\t\t\t\t\treturn Promise.reject( {\n\t\t\t\t\t\t\tcode: 'post_process',\n\t\t\t\t\t\t\tmessage: __(\n\t\t\t\t\t\t\t\t'Media upload failed. If this is a photo or a large image, please scale it down and try again.'\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.reject( response );\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn parseAndThrowError( response, options.parse );\n\t\t} )\n\t\t.then( ( response ) =>\n\t\t\tparseResponseAndNormalizeError( response, options.parse )\n\t\t);\n};\n\nexport default mediaUploadMiddleware;\n","/**\n * @type {import('../types').APIFetchMiddleware}\n */\nconst namespaceAndEndpointMiddleware = ( options, next ) => {\n\tlet path = options.path;\n\tlet namespaceTrimmed, endpointTrimmed;\n\n\tif (\n\t\ttypeof options.namespace === 'string' &&\n\t\ttypeof options.endpoint === 'string'\n\t) {\n\t\tnamespaceTrimmed = options.namespace.replace( /^\\/|\\/$/g, '' );\n\t\tendpointTrimmed = options.endpoint.replace( /^\\//, '' );\n\t\tif ( endpointTrimmed ) {\n\t\t\tpath = namespaceTrimmed + '/' + endpointTrimmed;\n\t\t} else {\n\t\t\tpath = namespaceTrimmed;\n\t\t}\n\t}\n\n\tdelete options.namespace;\n\tdelete options.endpoint;\n\n\treturn next( {\n\t\t...options,\n\t\tpath,\n\t} );\n};\n\nexport default namespaceAndEndpointMiddleware;\n","/**\n * @param {string} nonce\n * @return {import('../types').APIFetchMiddleware & { nonce: string }} A middleware to enhance a request with a nonce.\n */\nfunction createNonceMiddleware( nonce ) {\n\t/**\n\t * @type {import('../types').APIFetchMiddleware & { nonce: string }}\n\t */\n\tconst middleware = ( options, next ) => {\n\t\tconst { headers = {} } = options;\n\n\t\t// If an 'X-GC-Nonce' header (or any case-insensitive variation\n\t\t// thereof) was specified, no need to add a nonce header.\n\t\tfor ( const headerName in headers ) {\n\t\t\tif (\n\t\t\t\theaderName.toLowerCase() === 'x-gc-nonce' &&\n\t\t\t\theaders[ headerName ] === middleware.nonce\n\t\t\t) {\n\t\t\t\treturn next( options );\n\t\t\t}\n\t\t}\n\n\t\treturn next( {\n\t\t\t...options,\n\t\t\theaders: {\n\t\t\t\t...headers,\n\t\t\t\t'X-GC-Nonce': middleware.nonce,\n\t\t\t},\n\t\t} );\n\t};\n\n\tmiddleware.nonce = nonce;\n\n\treturn middleware;\n}\n\nexport default createNonceMiddleware;\n","/**\n * GeChiUI dependencies\n */\nimport { getQueryArg, normalizePath } from '@gechiui/url';\n\n/**\n * @param {Record<string, any>} preloadedData\n * @return {import('../types').APIFetchMiddleware} Preloading middleware.\n */\nfunction createPreloadingMiddleware( preloadedData ) {\n\tconst cache = Object.keys( preloadedData ).reduce( ( result, path ) => {\n\t\tresult[ normalizePath( path ) ] = preloadedData[ path ];\n\t\treturn result;\n\t}, /** @type {Record<string, any>} */ ( {} ) );\n\n\treturn ( options, next ) => {\n\t\tconst { parse = true } = options;\n\t\t/** @type {string | void} */\n\t\tlet rawPath = options.path;\n\t\tif ( ! rawPath && options.url ) {\n\t\t\tconst pathFromQuery = getQueryArg( options.url, 'rest_route' );\n\t\t\tif ( typeof pathFromQuery === 'string' ) {\n\t\t\t\trawPath = pathFromQuery;\n\t\t\t}\n\t\t}\n\t\tif ( typeof rawPath === 'string' ) {\n\t\t\tconst method = options.method || 'GET';\n\t\t\tconst path = normalizePath( rawPath );\n\n\t\t\tif ( 'GET' === method && cache[ path ] ) {\n\t\t\t\tconst cacheData = cache[ path ];\n\n\t\t\t\t// Unsetting the cache key ensures that the data is only used a single time\n\t\t\t\tdelete cache[ path ];\n\n\t\t\t\treturn Promise.resolve(\n\t\t\t\t\tparse\n\t\t\t\t\t\t? cacheData.body\n\t\t\t\t\t\t: new window.Response(\n\t\t\t\t\t\t\t\tJSON.stringify( cacheData.body ),\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstatus: 200,\n\t\t\t\t\t\t\t\t\tstatusText: 'OK',\n\t\t\t\t\t\t\t\t\theaders: cacheData.headers,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t  )\n\t\t\t\t);\n\t\t\t} else if (\n\t\t\t\t'OPTIONS' === method &&\n\t\t\t\tcache[ method ] &&\n\t\t\t\tcache[ method ][ path ]\n\t\t\t) {\n\t\t\t\tconst cacheData = cache[ method ][ path ];\n\n\t\t\t\t// Unsetting the cache key ensures that the data is only used a single time\n\t\t\t\tdelete cache[ method ][ path ];\n\n\t\t\t\treturn Promise.resolve( parse ? cacheData.body : cacheData );\n\t\t\t}\n\t\t}\n\n\t\treturn next( options );\n\t};\n}\n\nexport default createPreloadingMiddleware;\n","/**\n * Internal dependencies\n */\nimport namespaceAndEndpointMiddleware from './namespace-endpoint';\n\n/**\n * @param {string} rootURL\n * @return {import('../types').APIFetchMiddleware} Root URL middleware.\n */\nconst createRootURLMiddleware = ( rootURL ) => ( options, next ) => {\n\treturn namespaceAndEndpointMiddleware( options, ( optionsWithPath ) => {\n\t\tlet url = optionsWithPath.url;\n\t\tlet path = optionsWithPath.path;\n\t\tlet apiRoot;\n\n\t\tif ( typeof path === 'string' ) {\n\t\t\tapiRoot = rootURL;\n\n\t\t\tif ( -1 !== rootURL.indexOf( '?' ) ) {\n\t\t\t\tpath = path.replace( '?', '&' );\n\t\t\t}\n\n\t\t\tpath = path.replace( /^\\//, '' );\n\n\t\t\t// API root may already include query parameter prefix if site is\n\t\t\t// configured to use plain permalinks.\n\t\t\tif (\n\t\t\t\t'string' === typeof apiRoot &&\n\t\t\t\t-1 !== apiRoot.indexOf( '?' )\n\t\t\t) {\n\t\t\t\tpath = path.replace( '?', '&' );\n\t\t\t}\n\n\t\t\turl = apiRoot + path;\n\t\t}\n\n\t\treturn next( {\n\t\t\t...optionsWithPath,\n\t\t\turl,\n\t\t} );\n\t} );\n};\n\nexport default createRootURLMiddleware;\n","/**\n * GeChiUI dependencies\n */\nimport { addQueryArgs, hasQueryArg } from '@gechiui/url';\n\n/**\n * @type {import('../types').APIFetchMiddleware}\n */\nconst userLocaleMiddleware = ( options, next ) => {\n\tif (\n\t\ttypeof options.url === 'string' &&\n\t\t! hasQueryArg( options.url, '_locale' )\n\t) {\n\t\toptions.url = addQueryArgs( options.url, { _locale: 'user' } );\n\t}\n\n\tif (\n\t\ttypeof options.path === 'string' &&\n\t\t! hasQueryArg( options.path, '_locale' )\n\t) {\n\t\toptions.path = addQueryArgs( options.path, { _locale: 'user' } );\n\t}\n\n\treturn next( options );\n};\n\nexport default userLocaleMiddleware;\n","/**\n * GeChiUI dependencies\n */\nimport { __ } from '@gechiui/i18n';\n\n/**\n * Parses the apiFetch response.\n *\n * @param {Response} response\n * @param {boolean}  shouldParseResponse\n *\n * @return {Promise<any> | null | Response} Parsed response.\n */\nconst parseResponse = ( response, shouldParseResponse = true ) => {\n\tif ( shouldParseResponse ) {\n\t\tif ( response.status === 204 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn response.json ? response.json() : Promise.reject( response );\n\t}\n\n\treturn response;\n};\n\n/**\n * Calls the `json` function on the Response, throwing an error if the response\n * doesn't have a json function or if parsing the json itself fails.\n *\n * @param {Response} response\n * @return {Promise<any>} Parsed response.\n */\nconst parseJsonAndNormalizeError = ( response ) => {\n\tconst invalidJsonError = {\n\t\tcode: 'invalid_json',\n\t\tmessage: __( 'The response is not a valid JSON response.' ),\n\t};\n\n\tif ( ! response || ! response.json ) {\n\t\tthrow invalidJsonError;\n\t}\n\n\treturn response.json().catch( () => {\n\t\tthrow invalidJsonError;\n\t} );\n};\n\n/**\n * Parses the apiFetch response properly and normalize response errors.\n *\n * @param {Response} response\n * @param {boolean}  shouldParseResponse\n *\n * @return {Promise<any>} Parsed response.\n */\nexport const parseResponseAndNormalizeError = (\n\tresponse,\n\tshouldParseResponse = true\n) => {\n\treturn Promise.resolve(\n\t\tparseResponse( response, shouldParseResponse )\n\t).catch( ( res ) => parseAndThrowError( res, shouldParseResponse ) );\n};\n\n/**\n * Parses a response, throwing an error if parsing the response fails.\n *\n * @param {Response} response\n * @param {boolean}  shouldParseResponse\n * @return {Promise<any>} Parsed response.\n */\nexport function parseAndThrowError( response, shouldParseResponse = true ) {\n\tif ( ! shouldParseResponse ) {\n\t\tthrow response;\n\t}\n\n\treturn parseJsonAndNormalizeError( response ).then( ( error ) => {\n\t\tconst unknownError = {\n\t\t\tcode: 'unknown_error',\n\t\t\tmessage: __( 'An unknown error occurred.' ),\n\t\t};\n\n\t\tthrow error || unknownError;\n\t} );\n}\n","(function() { module.exports = window[\"gc\"][\"i18n\"]; }());","(function() { module.exports = window[\"gc\"][\"url\"]; }());"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AADA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAJA;AAQA;AASA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AAFA;AAIA;AAEA;AAEA;AACA;AACA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;ACpMA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAHA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AADA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AAGA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;AC/HA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AAHA;AAKA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;;;;;;;;;;;;;AC7FA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAFA;AAIA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAFA;AAFA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAMA;AACA;AACA;AAHA;AAOA;AAKA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;AACA;;;;;;;;;;;;ACpFA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}